<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>HoloCrystal • 粒子矩陣 + 投影機 (ImportMap)</title>

<!-- ❶ Import Map：把 'three' 與附加元件別名綁定到 CDN -->
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.149.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.149.0/examples/jsm/"
  }
}
</script>

<style>
  html,body{margin:0;height:100%;background:#0f1216;color:#cfd6e4;font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial}
  #ui{position:fixed;top:8px;left:8px;right:8px;display:flex;flex-wrap:wrap;gap:8px;align-items:center;z-index:10}
  #ui label{font-size:12px;opacity:.9}
  #ui input,#ui select{background:#151a20;border:1px solid #2a3240;color:#e7edf8;border-radius:6px;padding:6px 8px;outline:none}
  #ui input[type="number"]{width:72px}
  #ui .btn{padding:6px 10px;border:1px solid #2a3240;border-radius:6px;background:#1b222b;cursor:pointer}
  #debug{position:fixed;left:12px;bottom:10px;font:12px/1.4 ui-monospace,Consolas,monospace;color:#a9b4c7;opacity:.95;white-space:pre;background:#0f1216cc;border:1px solid #2a3240;border-radius:8px;padding:10px 12px;z-index:9;max-width:40ch}
  canvas{display:block}
  #build{position:fixed;right:10px;bottom:10px;font:12px ui-monospace,Consolas,monospace;color:#a9b4c7;opacity:.75}
</style>
</head>
<body>

<div id="ui">
  <label>X<input id="nx" type="number" min="1" max="128" step="1" value="24"></label>
  <label>Y<input id="ny" type="number" min="1" max="128" step="1" value="24"></label>
  <label>Z<input id="nz" type="number" min="1" max="128" step="1" value="24"></label>
  <label>間距<input id="spacing" type="number" step="0.01" value="0.06"></label>
  <label>半徑<input id="radius" type="number" step="0.001" value="0.005"></label>

  <label>投影機(1–4)<input id="pcams" type="number" min="1" max="4" step="1" value="2"></label>
  <label>FOV°<input id="fov" type="number" step="1" value="50"></label>
  <label>near<input id="near" type="number" step="0.01" value="0.1"></label>
  <label>far<input id="far" type="number" step="0.1" value="5"></label>
  <label>距離R<input id="rad" type="number" step="0.1" value="2.2" title="投影機距中心半徑"></label>

  <label>面向
    <select id="face">
      <option value="+x">+X</option>
      <option value="-x">-X</option>
      <option value="+y">+Y</option>
      <option value="-y">-Y</option>
      <option value="+z" selected>+Z</option>
      <option value="-z">-Z</option>
    </select>
  </label>

  <label><input id="autobox" type="checkbox" checked> 顯示外框</label>
  <label><input id="autorot" type="checkbox"> 自動旋轉</label>
  <label><input id="dbg" type="checkbox" checked> Debug</label>
  <button id="regen" class="btn">重新生成</button>
</div>

<pre id="debug"></pre>
<div id="build">BUILD v1.0.3</div>

<!-- ❷ 主程式：用 import map 指定的 CDN 來 import 三方模組 -->
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

const state = {
  nx:24, ny:24, nz:24,
  spacing:0.06, radius:0.005,
  pcams:2, fov:50, near:0.1, far:5,
  rad:2.2, face:'+z',
  autorot:false, autobox:true, dbg:true
};

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0f1216);

const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.01, 100);
camera.position.set(2.8,1.6,3.6);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

const grid = new THREE.GridHelper(100, 100, 0x374151, 0x2b3542);
grid.material.opacity = 0.6; grid.material.transparent = true;
scene.add(grid);

const boxHelper = new THREE.LineSegments(
  new THREE.EdgesGeometry(new THREE.BoxGeometry(1,1,1)),
  new THREE.LineBasicMaterial({color:0xffffff, transparent:true, opacity:0.6})
);
scene.add(boxHelper);

let instanced, projectors=[], frustums=[];
const tmpObj = new THREE.Object3D(), tmpMat = new THREE.Matrix4(), tmpPos = new THREE.Vector3();

function readUI(){
  state.nx = Math.max(1, Math.round(parseFloat(nx.value)));
  state.ny = Math.max(1, Math.round(parseFloat(ny.value)));
  state.nz = Math.max(1, Math.round(parseFloat(nz.value)));
  state.spacing = parseFloat(spacing.value);
  state.radius  = parseFloat(radius.value);
  state.pcams   = Math.max(1, Math.min(4, Math.round(parseFloat(pcams.value))));
  state.fov     = parseFloat(fov.value);
  state.near    = parseFloat(near.value);
  state.far     = parseFloat(far.value);
  state.rad     = parseFloat(rad.value);
  state.face    = face.value;
  state.autobox = autobox.checked;
  state.autorot = autorot.checked;
  state.dbg     = dbg.checked;
}

function faceToVector(face){
  switch(face){
    case '+x': return new THREE.Vector3( 1, 0, 0);
    case '-x': return new THREE.Vector3(-1, 0, 0);
    case '+y': return new THREE.Vector3( 0, 1, 0);
    case '-y': return new THREE.Vector3( 0,-1, 0);
    case '+z': return new THREE.Vector3( 0, 0, 1);
    case '-z': return new THREE.Vector3( 0, 0,-1);
  }
}

function buildParticles(){
  if (instanced) { scene.remove(instanced); instanced.geometry.dispose(); instanced.material.dispose(); }
  const {nx,ny,nz,spacing:sp,radius:r} = state;
  const geo = new THREE.SphereGeometry(r, 12, 12);
  const mat = new THREE.MeshBasicMaterial({color:0xffffff});
  const count = nx*ny*nz;
  instanced = new THREE.InstancedMesh(geo, mat, count);
  instanced.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
  const x0 = -(nx-1)*sp*0.5, y0 = -(ny-1)*sp*0.5, z0 = -(nz-1)*sp*0.5;
  let i = 0;
  for (let ix=0; ix<nx; ix++)
    for (let iy=0; iy<ny; iy++)
      for (let iz=0; iz<nz; iz++){
        tmpObj.position.set(x0+ix*sp, y0+iy*sp, z0+iz*sp);
        tmpObj.updateMatrix();
        instanced.setMatrixAt(i++, tmpObj.matrix);
      }
  instanced.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(count*3),3);
  scene.add(instanced);
  boxHelper.scale.set(nx*sp, ny*sp, nz*sp);
}

function buildProjectors(){
  projectors.forEach(p=>scene.remove(p.helper));
  projectors.length = 0; frustums.length = 0;
  const n = THREE.MathUtils.clamp(state.pcams,1,4);
  const dir = faceToVector(state.face).clone();
  for (let i=0;i<n;i++){
    const cam = new THREE.PerspectiveCamera(state.fov, 1, state.near, state.far);
    const angle = (i/n)*Math.PI*2;
    const up = Math.abs(dir.y)>0.9 ? new THREE.Vector3(1,0,0) : new THREE.Vector3(0,1,0);
    const right = new THREE.Vector3().crossVectors(up, dir).normalize();
    const orthoUp = new THREE.Vector3().crossVectors(dir, right).normalize();
    const pos = new THREE.Vector3()
      .addScaledVector(right, Math.cos(angle)*state.rad)
      .addScaledVector(orthoUp, Math.sin(angle)*state.rad)
      .addScaledVector(dir, 0.0001);
    cam.position.copy(pos); cam.lookAt(0,0,0);
    const helper = new THREE.CameraHelper(cam);
    helper.material.color = new THREE.Color(0xffb74d);
    scene.add(helper);
    projectors.push({cam, helper});
  }
}

function updateCoverage(){
  const count = instanced.count;
  frustums = projectors.map(p=>{
    p.cam.updateProjectionMatrix(); p.cam.updateMatrixWorld(true);
    const pv = new THREE.Matrix4().multiplyMatrices(p.cam.projectionMatrix, p.cam.matrixWorldInverse);
    return new THREE.Frustum().setFromProjectionMatrix(pv);
  });
  const arr = instanced.instanceColor.array, col = new THREE.Color();
  for (let i=0;i<count;i++){
    instanced.getMatrixAt(i, tmpMat);
    tmpPos.setFromMatrixPosition(tmpMat);
    let seen = 0; for (const f of frustums) if (f.containsPoint(tmpPos)) seen++;
    const a = [0.2,0.4,0.6,1.0][Math.min(seen,4)-1] ?? 0.2;
    col.setScalar(a);
    arr[i*3+0]=col.r; arr[i*3+1]=col.g; arr[i*3+2]=col.b;
  }
  instanced.instanceColor.needsUpdate = true;
}

function writeDebug() {
  const dbgEl = document.getElementById('debug');
  if (!state.dbg) { dbgEl.textContent = ''; return; }

  const ext = [state.nx * state.spacing, state.ny * state.spacing, state.nz * state.spacing]
    .map(v => v.toFixed(3))
    .join(' × ');

  dbgEl.textContent =
    'index.html (ImportMap)\nTHREE r149\n' +
    'grid : ' + state.nx + ' × ' + state.ny + ' × ' + state.nz + '\n' +
    'spacing : ' + state.spacing + '\n' +
    'radius  : ' + state.radius + '\n' +
    'extent  : ' + ext + '\n' +
    'cams    : ' + state.pcams + ', fov:' + state.fov + ', near:' + state.near + ', far:' + state.far + ', R:' + state.rad + ', face:' + state.face + '\n' +
    'rotate  : ' + (state.autorot ? 'on' : 'off') + '\n';
}

function regenAll(){
  readUI();
  boxHelper.visible = state.autobox;
  buildParticles();
  buildProjectors();
  updateCoverage();
  writeDebug();
}

function onResize(){
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
}
addEventListener('resize', onResize);

regen.addEventListener('click', regenAll);
['nx','ny','nz','spacing','radius','pcams','fov','near','far','rad','face','autobox','autorot','dbg']
  .forEach(id => document.getElementById(id).addEventListener('change', regenAll));

regenAll();

const clock = new THREE.Clock();
renderer.setAnimationLoop(()=>{
  const t = clock.getElapsedTime();
  if (state.autorot){
    const r = Math.sin(t*0.4)*0.12;
    boxHelper.rotation.y = t*0.18; boxHelper.rotation.x = r;
    if (instanced) instanced.rotation.copy(boxHelper.rotation);
  }
  controls.update();
  renderer.render(scene, camera);
});
</script>
</body>
</html>
